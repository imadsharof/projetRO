import numpy as np
from pulp import LpProblem, LpMinimize, LpVariable, lpSum, value, PULP_CBC_CMD
import tkinter as tk
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

weight_production = 1
weight_distance = 1
weight_compactness = 1
budget= 50
best_total_score = 0
nb_test = 10


#Fonction qui charge les données à partir des fichiers txt
def load_data(filename):
    with open(filename, 'r') as f:
        data = [[int(value) for value in line.strip()] for line in f.readlines()]
    return data


# Fonction qui crée la matrice usage_map
def create_usage_map_matrix(file_path):
    with open(file_path, 'r') as file:
        lignes = file.readlines()

    matrix = []
    for ligne in lignes:
        matrix_ligne = []
        for c in ligne:
            if c == ' ':
                matrix_ligne.append('')
            elif c == 'R':
                matrix_ligne.append('R')
            elif c == 'C':
                matrix_ligne.append('C')
        matrix.append(matrix_ligne)
        #print(ligne)
    return matrix

### Initalisation de la région : usage_map, cost_map et production_map
"""
usage_map = create_usage_map_matrix("donnes_test/Usage_map_test.txt")
cost_map = load_data("donnes_test/Cost_map_test.txt")
production_map = load_data("donnes_test/Production_map_test.txt")
"""
usage_map = create_usage_map_matrix("donnes_V2/Usage_map.txt")
cost_map = load_data("donnes_V2/Cost_map.txt")
production_map = load_data("donnes_V2/Production_map.txt")


### Indices

ColonneU = len(usage_map[0])
LigneU = len(usage_map)

### Constantes

# Fonction qui crée la matrice route
def create_route_matrix():
    matrix = []
    for l in range(LigneU):
        matrix.append([])
        for c in range(ColonneU) :
            if usage_map[l][c] == "R" :
                matrix[l].append(1)
            else :
                matrix[l].append(0)
    return matrix

Route = create_route_matrix()

# Fonction qui crée la matrice habitation
def create_habitation_matrix():
    matrix = []
    for l in range(LigneU) :
        matrix.append([])
        for c in range(ColonneU) :
            if usage_map[l][c] == "C":
                matrix[l].append(1)
            else :
                matrix[l].append(0)
    return matrix

Habitation = create_habitation_matrix()

# Fonction qui crée la matrice de distance
# Forme de l'algorithme de Dijkstra pour permettre de calculer le plus court chemin entre une parcelle et une habitation H
def create_distance_matrix():
    # Étape 1 : Initialiser la matrice de distance avec de grandes valeurs
    D = []
    for l in range(LigneU):
        row = []
        for c in range(ColonneU):
            # Nous commençons avec une grande valeur pour représenter "l'infini"
            row.append(10000)
        D.append(row)

    # Étape 2 : Mettre la distance à 0 pour toutes les cellules habitables
    for l in range(LigneU):
        for c in range(ColonneU):
            if Habitation[l][c] == 1:
                # Si la cellule est habitable, sa distance à elle-même est 0
                D[l][c] = 0

    # Étape 3 : Initialiser la file d'attente avec les cellules habitables
    queue = []
    for l in range(LigneU):
        for c in range(ColonneU):
            if Habitation[l][c] == 1:
                # Si la cellule est habitable, nous l'ajoutons à la file d'attente pour l'explorer plus tard
                queue.append((l, c))

    # Étape 4 : Parcourir la file d'attente et mettre à jour les distances
    while len(queue) > 0:
        # Nous retirons la première cellule de la file d'attente pour l'explorer
        l, c = queue.pop(0)

        # Nous explorons tous les voisins de la cellule actuelle
        for dl, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            # Nous calculons les coordonnées du voisin
            nl, nc = l + dl, c + dc

            # Nous vérifions si le voisin est dans les limites de la grille et n'est pas une route
            if 0 <= nl < LigneU and 0 <= nc < ColonneU and Route[nl][nc] != 1:
                # Nous calculons la distance à travers la cellule actuelle
                new_distance = D[l][c] + 1

                # Si cette nouvelle distance est plus petite que la distance actuelle du voisin, nous mettons à jour la distance du voisin
                if new_distance < D[nl][nc]:
                    D[nl][nc] = new_distance

                    # Nous ajoutons le voisin à la file d'attente pour explorer ses voisins plus tard
                    queue.append((nl, nc))

    # À la fin, D contient la distance minimale de chaque cellule à la cellule habitable la plus proche
    return D

Distance = create_distance_matrix()


candidates = []
for l in range(LigneU):
    for c in range(ColonneU):
        if not(Habitation[l][c] == 1) and not(Route[l][c] == 1) :
            candidates.append((l, c))
candidates = sorted(candidates, key=lambda x: -(production_map[x[0]][x[1]] / Distance[x[0]][x[1]]))


def compactness_score_matrix(LigneU, ColonneU, best_parcel):
    score_matrix = np.zeros((LigneU, ColonneU))
    best_l, best_c = best_parcel

    # Calculer les scores de compacité uniquement pour les cellules proches
    for l in range(LigneU):
        for c in range(ColonneU):
            if (l, c) == best_parcel:
                score_matrix[l][c] = 1000  # Score infini pour la meilleure parcelle
            else:
                min_distance = abs(l - best_l) + abs(c - best_c)
                score_matrix[l][c] = 100 / min_distance  # Score inverse de la distance minimale

    return score_matrix

def solve_land_purchasing_problem(LigneU, ColonneU, production_map, Distance, score_matrix, Route, Habitation, cost_map, budget, weight_production, weight_distance, weight_compactness):
    # 1. Initialiser le problème et les variables de décision binaires (une pour chaque parcelle).
    model = LpProblem(name="Land_purchasing_problem", sense=LpMinimize)
    parcels = [LpVariable(name=f"Parcel_{l}_{c}", cat="Binary") for l in range(LigneU) for c in range(ColonneU)]

    # 2. Ajouter les contraintes
    # Chaque parcelle ne peut être achetée qu'une fois
    for l in range(LigneU):
        for c in range(ColonneU):
            model += (parcels[l * ColonneU + c] <= 1 - Route[l][c] - Habitation[l][c], f"Parcel_{l}_{c}_constraint")

    # Respecter le budget
    total_cost = lpSum([cost_map[l][c] * parcels[l * ColonneU + c] for l in range(LigneU) for c in range(ColonneU)])
    model += (total_cost <= budget, "Budget_constraint")

    # 3. Définir la fonction objectif agrégée

    objective = - weight_production * lpSum([production_map[l][c] * parcels[l * ColonneU + c] for l in range(LigneU) for c in range(ColonneU)]) \
               + weight_distance * lpSum([Distance[l][c] * parcels[l * ColonneU + c] for l in range(LigneU) for c in range(ColonneU)]) \
                - weight_compactness * lpSum([score_matrix[l][c] * parcels[l * ColonneU + c] for l in range(LigneU) for c in range(ColonneU)])

    # Maximiser la fonction objectif agrégée
    model += objective

    # 4. Résoudre le problème
    model.solve()

    # Récupérer la prochaine parcelle achetée
    price = 0
    print("Parcelles acheter")
    for l in range(LigneU):
        for c in range(ColonneU):
            if parcels[l * ColonneU + c].varValue == 1:
                print(f"Parcelle ({l}, {c})")
                price += cost_map[l][c]
                usage_map[l][c] = 'A'

    price = price * 10000
    print("Le prix des parcelles acheter dans cette zone est de:",price,"€")


for test in range(nb_test):
    print(f"Test numéro {test + 1}:")
    candidates = sorted(candidates, key=lambda x: -(production_map[x[0]][x[1]] / Distance[x[0]][x[1]]))
    best_parcel = candidates[test]

    print("Test sur la zone", test, "autour de la parcelle",  ":", best_parcel)

    # Acheter les parcelles autour de la meilleure parcelle en utilisant solve_land_purchasing_problem
    score_matrix = compactness_score_matrix(LigneU, ColonneU, best_parcel)
    solve_land_purchasing_problem(LigneU, ColonneU, production_map, Distance, score_matrix, Route, Habitation, cost_map, budget, weight_production, weight_distance, weight_compactness)

    total_score = 0

    for l in range(LigneU):
        for c in range(ColonneU):
            if usage_map[l][c] == 'A':
                score = production_map[l][c] / Distance[l][c]
                total_score += score

    for i in range(LigneU):
        for j in range(ColonneU):
            if usage_map[i][j] == 'A':
                usage_map[i][j] = ''


    print("Score total de la zone", test , ":", total_score)

    if total_score > best_total_score:
        best_total_score = total_score
        real_best_parcel = best_parcel


# Afficher la meilleure parcelle
print("La meilleur zone sera autour de la parcelle:", real_best_parcel)
print("Son score est de:", best_total_score)

# Appeler la fonction pour résoudre le problème d'achat des parcelles
score_matrix = compactness_score_matrix(LigneU, ColonneU, real_best_parcel)
solve_land_purchasing_problem(LigneU, ColonneU, production_map, Distance, score_matrix, Route, Habitation, cost_map,
                              budget, weight_production, weight_distance, weight_compactness)

color_mapping = {
    'C': 'blue',
    'R': 'gray',
    'A': 'red',
    '': 'black'
}


def draw_grid(matrix):
    root = tk.Tk()
    root.title("Grid")

    # Calcul de la taille de la grille en fonction de la matrice
    rows = len(matrix)
    cols = len(matrix[0])

    # Taille des carrés de la grille
    square_size = 800/len(matrix[0])

    # Création du canevas
    canvas = tk.Canvas(root, width=cols * square_size, height=rows * square_size)
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

    # Création de la barre de défilement verticale
    yscrollbar = tk.Scrollbar(root, orient=tk.VERTICAL, command=canvas.yview)
    yscrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Création de la barre de défilement horizontale
    xscrollbar = tk.Scrollbar(root, orient=tk.HORIZONTAL, command=canvas.xview)
    xscrollbar.pack(side=tk.BOTTOM, fill=tk.X)

    # Configuration du canevas pour prendre en compte les défilements
    canvas.configure(yscrollcommand=yscrollbar.set, xscrollcommand=xscrollbar.set)
    canvas.configure(scrollregion=canvas.bbox(tk.ALL))

    # Parcours de la matrice et dessin des éléments
    for row in range(rows):
        for col in range(cols):
            element = matrix[row][col]
            color = color_mapping.get(element, 'black')

            # Dessin d'un rectangle avec la couleur correspondante
            canvas.create_rectangle(col * square_size, row * square_size, (col + 1) * square_size, (row + 1) * square_size, fill=color)

    root.mainloop()
draw_grid(usage_map)









