from pulp import LpProblem, LpMinimize, LpVariable, lpSum, value, PULP_CBC_CMD
from mpl_toolkits.mplot3d import Axes3D

import matplotlib.pyplot as plt
import numpy as np


#Fonction qui charge les données à partir des fichiers txt
def load_data(filename):
    with open(filename, 'r') as f:
        data = [[int(value) for value in line.strip()] for line in f.readlines()]
    return data


# Fonction qui crée la matrice usage_map
def create_usage_map_matrix(file_path):
    with open(file_path, 'r') as file:
        lignes = file.readlines()

    matrix = []
    for ligne in lignes:
        matrix_ligne = []
        for c in ligne:
            if c == ' ':
                matrix_ligne.append('V')
            elif c == 'R':
                matrix_ligne.append('R')
            elif c == 'C':
                matrix_ligne.append('C')
        matrix.append(matrix_ligne)
        #print(ligne)
    return matrix

### Initalisation de la région : usage_map, cost_map et production_map
usage_map = create_usage_map_matrix("donnes_V2/Usage_map.txt")
cost_map = load_data("donnes_V2/Cost_map.txt")
production_map = load_data("donnes_V2/Production_map.txt")


### Indices

ColonneU = len(usage_map[0])
LigneU = len(usage_map)


### Constantes

# Fonction qui crée la matrice route
def create_route_matrix():
    matrix = []
    for l in range(LigneU):
        matrix.append([])
        for c in range(ColonneU) :
            if usage_map[l][c] == "R" :
                matrix[l].append(1)
            else :
                matrix[l].append(0)
    return matrix

Route = create_route_matrix()

# Fonction qui crée la matrice habitation
def create_habitation_matrix():
    matrix = []
    for l in range(LigneU) :
        matrix.append([])
        for c in range(ColonneU) :
            if usage_map[l][c] == "C":
                matrix[l].append(1)
            else :
                matrix[l].append(0)
    return matrix

Habitation = create_habitation_matrix()

# Fonction qui crée la matrice de distance
# Forme de l'algorithme de Dijkstra pour permettre de calculer le plus court chemin entre une parcelle et une habitation H
def create_distance_matrix():
    # Étape 1 : Initialiser la matrice de distance avec de grandes valeurs
    D = []
    for l in range(LigneU):
        row = []
        for c in range(ColonneU):
            # Nous commençons avec une grande valeur pour représenter "l'infini"
            row.append(10000)
        D.append(row)

    # Étape 2 : Mettre la distance à 0 pour toutes les cellules habitables
    for l in range(LigneU):
        for c in range(ColonneU):
            if Habitation[l][c] == 1:
                # Si la cellule est habitable, sa distance à elle-même est 0
                D[l][c] = 0

    # Étape 3 : Initialiser la file d'attente avec les cellules habitables
    queue = []
    for l in range(LigneU):
        for c in range(ColonneU):
            if Habitation[l][c] == 1:
                # Si la cellule est habitable, nous l'ajoutons à la file d'attente pour l'explorer plus tard
                queue.append((l, c))

    # Étape 4 : Parcourir la file d'attente et mettre à jour les distances
    while len(queue) > 0:
        # Nous retirons la première cellule de la file d'attente pour l'explorer
        l, c = queue.pop(0)

        # Nous explorons tous les voisins de la cellule actuelle
        for dl, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            # Nous calculons les coordonnées du voisin
            nl, nc = l + dl, c + dc

            # Nous vérifions si le voisin est dans les limites de la grille et n'est pas une route
            if 0 <= nl < LigneU and 0 <= nc < ColonneU and Route[nl][nc] != 1:
                # Nous calculons la distance à travers la cellule actuelle
                new_distance = D[l][c] + 1

                # Si cette nouvelle distance est plus petite que la distance actuelle du voisin, nous mettons à jour la distance du voisin
                if new_distance < D[nl][nc]:
                    D[nl][nc] = new_distance

                    # Nous ajoutons le voisin à la file d'attente pour explorer ses voisins plus tard
                    queue.append((nl, nc))

    # À la fin, D contient la distance minimale de chaque cellule à la cellule habitable la plus proche
    return D


Distance = create_distance_matrix()


print(usage_map)

def create_border_matrix():
    # Etape 1 : Initialisation de la matrice B
    B = []
    for _ in range(LigneU):
        row = []
        for _ in range(ColonneU):
            row.append(0)
        B.append(row)

    # Etape 2 : Parcourir chaque cellule de la matrice d'utilisation
    for l in range(LigneU):
        for c in range(ColonneU):
            # Etape 3 : Définir les directions pour vérifier les voisins
            directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

            # Etape 4 : Vérifier chaque voisin de la cellule actuelle
            for direction in directions:
                dl, dc = direction
                nl, nc = l + dl, c + dc

                # Etape 5 : Vérifier si le voisin est dans les limites de la matrice
                if 0 <= nl < LigneU and 0 <= nc < ColonneU:
                    # Etape 6 : Vérifier si le voisin est une parcelle non achetée
                    if usage_map[nl][nc] == 'V':
                        # Etape 7 : Si oui, marquer la cellule actuelle comme un bord extérieur
                        B[l][c] = 1
                        # Etape 8 : Pas besoin de vérifier d'autres voisins
                        break

    # Etape 9 : Retourner la matrice B
    return B


Bord = create_border_matrix()


def solve_land_purchasing_problem(LigneU, ColonneU, production_map, Distance, Bord, Route, Habitation, cost_map,budget):
    # 1. Initialiser le problème et les variables de décision binaires (une pour chaque parcelle).
    model = LpProblem(name="Land purchasing problem", sense=LpMinimize)
    parcels = [LpVariable(name=f"Parcel_{l}_{c}", cat="Binary") for l in range(LigneU) for c in range(ColonneU)]

    # 2. Ajouter les contraintes
    # Chaque parcelle ne peut être achetée qu'une fois
    for l in range(LigneU):
        for c in range(ColonneU):
            model += (parcels[l * ColonneU + c] <= 1 - Route[l][c] - Habitation[l][c], f"Parcel_{l}_{c}_constraint")

    # Respecter le budget
    total_cost = lpSum([cost_map[l][c] * parcels[l * ColonneU + c] for l in range(LigneU) for c in range(ColonneU)])
    model += (total_cost <= budget, "Budget_constraint")

    # 3. Définir la fonction objectif
    objectif1 = lpSum([production_map[l][c] * parcels[l * ColonneU + c] for l in range(LigneU) for c in range(ColonneU)])
    objectif2 = lpSum([Distance[l][c] * parcels[l * ColonneU + c] for l in range(LigneU) for c in range(ColonneU)])
    objectif3 = lpSum([Bord[l][c] * parcels[l * ColonneU + c] for l in range(LigneU) for c in range(ColonneU)])

    # Maximiser la production et minimiser la distance et le bord
    model += (-objectif1 + objectif2 + objectif3)

    # 4. Résoudre le problème
    model.solve(solver=PULP_CBC_CMD(msg=True, timeLimit=300, options=['--mipgap', '1e-10'], keepFiles=True))

    # 5. Afficher les résultats
    print("Parcels purchased:")
    for l in range(LigneU):
        for c in range(ColonneU):
            if parcels[l * ColonneU + c].varValue == 1:
                print(f"Parcel ({l}, {c})")
    print(Bord)

solve_land_purchasing_problem(LigneU, ColonneU, production_map, Distance, Bord, Route, Habitation, cost_map, 50)

