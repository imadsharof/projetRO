from matplotlib import colors
from pulp import LpProblem, LpMinimize, LpVariable, lpSum, value, PULP_CBC_CMD
from mpl_toolkits.mplot3d import Axes3D

import matplotlib.pyplot as plt
import numpy as np
import tkinter as tk

#Fonction qui charge les données à partir des fichiers txt
def load_data(filename):
    with open(filename, 'r') as f:
        data = [[int(value) for value in line.strip()] for line in f.readlines()]
    return data


# Fonction qui crée la matrice usage_map
def create_usage_map_matrix(file_path):
    with open(file_path, 'r') as file:
        lignes = file.readlines()

    matrix = []
    for ligne in lignes:
        matrix_ligne = []
        for c in ligne:
            if c == ' ':
                matrix_ligne.append('')
            elif c == 'R':
                matrix_ligne.append('R')
            elif c == 'C':
                matrix_ligne.append('C')
        matrix.append(matrix_ligne)
        #print(ligne)
    return matrix

### Initalisation de la région : usage_map, cost_map et production_map

usage_map = create_usage_map_matrix("donnes_test/Usage_map_test.txt")
cost_map = load_data("donnes_test/Cost_map_test.txt")
production_map = load_data("donnes_test/Production_map_test.txt")
"""
usage_map = create_usage_map_matrix("donnes_V2/Usage_map.txt")
cost_map = load_data("donnes_V2/Cost_map.txt")
production_map = load_data("donnes_V2/Production_map.txt")
"""


### Indices

ColonneU = len(usage_map[0])
LigneU = len(usage_map)

### Constantes

# Fonction qui crée la matrice route
def create_route_matrix():
    matrix = []
    for l in range(LigneU):
        matrix.append([])
        for c in range(ColonneU) :
            if usage_map[l][c] == "R" :
                matrix[l].append(1)
            else :
                matrix[l].append(0)
    return matrix

Route = create_route_matrix()

# Fonction qui crée la matrice habitation
def create_habitation_matrix():
    matrix = []
    for l in range(LigneU) :
        matrix.append([])
        for c in range(ColonneU) :
            if usage_map[l][c] == "C":
                matrix[l].append(1)
            else :
                matrix[l].append(0)
    return matrix

Habitation = create_habitation_matrix()

# Fonction qui crée la matrice de distance
# Forme de l'algorithme de Dijkstra pour permettre de calculer le plus court chemin entre une parcelle et une habitation H
def create_distance_matrix():
    # Étape 1 : Initialiser la matrice de distance avec de grandes valeurs
    D = []
    for l in range(LigneU):
        row = []
        for c in range(ColonneU):
            # Nous commençons avec une grande valeur pour représenter "l'infini"
            row.append(10000)
        D.append(row)

    # Étape 2 : Mettre la distance à 0 pour toutes les cellules habitables
    for l in range(LigneU):
        for c in range(ColonneU):
            if Habitation[l][c] == 1:
                # Si la cellule est habitable, sa distance à elle-même est 0
                D[l][c] = 0

    # Étape 3 : Initialiser la file d'attente avec les cellules habitables
    queue = []
    for l in range(LigneU):
        for c in range(ColonneU):
            if Habitation[l][c] == 1:
                # Si la cellule est habitable, nous l'ajoutons à la file d'attente pour l'explorer plus tard
                queue.append((l, c))

    # Étape 4 : Parcourir la file d'attente et mettre à jour les distances
    while len(queue) > 0:
        # Nous retirons la première cellule de la file d'attente pour l'explorer
        l, c = queue.pop(0)

        # Nous explorons tous les voisins de la cellule actuelle
        for dl, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            # Nous calculons les coordonnées du voisin
            nl, nc = l + dl, c + dc

            # Nous vérifions si le voisin est dans les limites de la grille et n'est pas une route
            if 0 <= nl < LigneU and 0 <= nc < ColonneU and Route[nl][nc] != 1:
                # Nous calculons la distance à travers la cellule actuelle
                new_distance = D[l][c] + 1

                # Si cette nouvelle distance est plus petite que la distance actuelle du voisin, nous mettons à jour la distance du voisin
                if new_distance < D[nl][nc]:
                    D[nl][nc] = new_distance

                    # Nous ajoutons le voisin à la file d'attente pour explorer ses voisins plus tard
                    queue.append((nl, nc))

    # À la fin, D contient la distance minimale de chaque cellule à la cellule habitable la plus proche
    return D


Distance = create_distance_matrix()




def solve_land_purchasing_problem(LigneU, ColonneU, production_map, Distance, Route, Habitation, cost_map, budget, weight_production, weight_distance, weight_compactness):
    # 1. Initialiser le problème et les variables de décision binaires (une pour chaque parcelle).
    model = LpProblem(name="Land purchasing problem", sense=LpMinimize)
    parcels = [LpVariable(name=f"Parcel_{l}_{c}", cat="Binary") for l in range(LigneU) for c in range(ColonneU)]

    # 2. Ajouter les contraintes
    # Chaque parcelle ne peut être achetée qu'une fois
    for l in range(LigneU):
        for c in range(ColonneU):
            model += (parcels[l * ColonneU + c] <= 1 - Route[l][c] - Habitation[l][c], f"Parcel_{l}_{c}_constraint")

    # Respecter le budget
    total_cost = lpSum([cost_map[l][c] * parcels[l * ColonneU + c] for l in range(LigneU) for c in range(ColonneU)])
    model += (total_cost <= budget, "Budget_constraint")
    # Chaque parcelle achetée doit être voisine d'une autre parcelle achetée (à l'exception de la première parcelle)
    for l in range(LigneU):
        for c in range(ColonneU):
            if l == 0 and c == 0:  # Première parcelle
                continue
            neighbors = []
            if l > 0:
                neighbors.append(parcels[(l - 1) * ColonneU + c])
            if l < LigneU - 1:
                neighbors.append(parcels[(l + 1) * ColonneU + c])
            if c > 0:
                neighbors.append(parcels[l * ColonneU + c - 1])
            if c < ColonneU - 1:
                neighbors.append(parcels[l * ColonneU + c + 1])

            model += (lpSum(neighbors) >= parcels[l * ColonneU + c], f"Adjacent_constraint_{l}_{c}")




    # 3. Définir la fonction objectif agrégée
    objective = -weight_production * lpSum([production_map[l][c] * parcels[l * ColonneU + c] for l in range(LigneU) for c in range(ColonneU)]) \
               + weight_distance * lpSum([Distance[l][c] * parcels[l * ColonneU + c] for l in range(LigneU) for c in range(ColonneU)]) \
               - weight_compactness * calculate_compactness(parcels, LigneU, ColonneU)

    # Maximiser la fonction objectif agrégée
    model += objective

    # 4. Résoudre le problème
    model.solve()

    # 5. Afficher les résultats
    price = 0
    print("Parcels purchased:")
    for l in range(LigneU):
        for c in range(ColonneU):
            if parcels[l * ColonneU + c].varValue == 1:
                print(f"Parcel ({l}, {c})")
                price += cost_map[l][c]
                usage_map[l][c] = 'A'

    print(price)

# Fonction pour calculer la compacité
def calculate_compactness(parcels, LigneU, ColonneU):
    # Créer une matrice binaire pour les parcelles achetées
    purchased_parcels = [[parcels[l * ColonneU + c] for c in range(ColonneU)] for l in range(LigneU)]

    # Calculer le nombre de parcelles achetées et le périmètre de la zone achetée
    num_purchased_parcels = sum(sum(row) for row in purchased_parcels)
    perimeter = 0

    # Calculer le périmètre en parcourant les parcelles achetées
    for l in range(LigneU):
        for c in range(ColonneU):
            if purchased_parcels[l][c] == 1:
                # Vérifier les parcelles voisines pour augmenter le périmètre si elles sont vides
                if l > 0 and  purchased_parcels[l - 1][c] == 0:
                    perimeter += 1
                if l < LigneU - 1 and purchased_parcels[l + 1][c] == 0:
                    perimeter += 1
                if c > 0 and  purchased_parcels[l][c - 1] == 0 :
                    perimeter += 1
                if c < ColonneU - 1 and  purchased_parcels[l][c + 1] ==0:
                    perimeter += 1

    # Calculer la compacité en divisant le nombre de parcelles achetées par le périmètre
    compactness = num_purchased_parcels / perimeter if perimeter > 0 else 0


    return compactness


weight_production = 1
weight_distance = 0.01
weight_compactness = 1
budget=50

solve_land_purchasing_problem(LigneU, ColonneU, production_map, Distance, Route, Habitation, cost_map, budget, weight_production, weight_distance, weight_compactness)

color_mapping = {
    'C': 'blue',
    'R': 'gray',
    'A': 'red',
    '': 'black'
}


def draw_grid(matrix):
    root = tk.Tk()
    root.title("Grid")

    # Calcul de la taille de la grille en fonction de la matrice
    rows = len(matrix)
    cols = len(matrix[0])

    # Taille des carrés de la grille
    square_size = 800/len(matrix[0])

    # Création du canevas
    canvas = tk.Canvas(root, width=cols * square_size, height=rows * square_size)
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

    # Création de la barre de défilement verticale
    yscrollbar = tk.Scrollbar(root, orient=tk.VERTICAL, command=canvas.yview)
    yscrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Création de la barre de défilement horizontale
    xscrollbar = tk.Scrollbar(root, orient=tk.HORIZONTAL, command=canvas.xview)
    xscrollbar.pack(side=tk.BOTTOM, fill=tk.X)

    # Configuration du canevas pour prendre en compte les défilements
    canvas.configure(yscrollcommand=yscrollbar.set, xscrollcommand=xscrollbar.set)
    canvas.configure(scrollregion=canvas.bbox(tk.ALL))

    # Parcours de la matrice et dessin des éléments
    for row in range(rows):
        for col in range(cols):
            element = matrix[row][col]
            color = color_mapping.get(element, 'black')

            # Dessin d'un rectangle avec la couleur correspondante
            canvas.create_rectangle(col * square_size, row * square_size, (col + 1) * square_size, (row + 1) * square_size, fill=color)

    root.mainloop()
draw_grid(usage_map)
