from pulp import LpProblem, LpMinimize, LpVariable, lpSum, value
from mpl_toolkits.mplot3d import Axes3D

import matplotlib.pyplot as plt
import numpy as np


#Fonction qui charge les données à partir des fichiers txt
def load_data(filename):
    with open(filename, 'r') as f:
        data = [[int(value) for value in line.strip()] for line in f.readlines()]
    return data


# Fonction qui crée la matrice usage_map
def create_usage_map_matrix(file_path):
    with open(file_path, 'r') as file:
        lignes = file.readlines()

    matrix = []
    for ligne in lignes:
        matrix_ligne = []
        for c in ligne:
            if c == ' ':
                matrix_ligne.append('')
            elif c == 'R':
                matrix_ligne.append('R')
            elif c == 'C':
                matrix_ligne.append('C')
        matrix.append(matrix_ligne)
        #print(ligne)
    return matrix

### Initalisation de la région : usage_map, cost_map et production_map
usage_map = create_usage_map_matrix("donnes_V2/Usage_map.txt")
cost_map = load_data("donnes_V2/Cost_map.txt")
production_map = load_data("donnes_V2/Production_map.txt")



### Indices

ColonneU = len(usage_map[0])
LigneU = len(usage_map)


### Constantes

# Fonction qui crée la matrice route
def create_route_matrix():
    matrix = []
    for l in range(LigneU):
        matrix.append([])
        for c in range(ColonneU) :
            if usage_map[l][c] == "R" :
                matrix[l].append(1)
            else :
                matrix[l].append(0)
    return matrix

Route = create_route_matrix()

# Fonction qui crée la matrice habitation
def create_habitation_matrix():
    matrix = []
    for l in range(LigneU) :
        matrix.append([])
        for c in range(ColonneU) :
            if usage_map[l][c] == "C":
                matrix[l].append(1)
            else :
                matrix[l].append(0)
    return matrix

Habitation = create_habitation_matrix()

# Fonction qui crée la matrice de distance
# Forme de l'algorithme de Dijkstra pour permettre de calculer le plus court chemin entre une parcelle et une habitation H
def create_distance_matrix():
    # Étape 1 : Initialiser la matrice de distance avec de grandes valeurs
    D = []
    for l in range(LigneU):
        row = []
        for c in range(ColonneU):
            # Nous commençons avec une grande valeur pour représenter "l'infini"
            row.append(10000)
        D.append(row)

    # Étape 2 : Mettre la distance à 0 pour toutes les cellules habitables
    for l in range(LigneU):
        for c in range(ColonneU):
            if Habitation[l][c] == 1:
                # Si la cellule est habitable, sa distance à elle-même est 0
                D[l][c] = 0

    # Étape 3 : Initialiser la file d'attente avec les cellules habitables
    queue = []
    for l in range(LigneU):
        for c in range(ColonneU):
            if Habitation[l][c] == 1:
                # Si la cellule est habitable, nous l'ajoutons à la file d'attente pour l'explorer plus tard
                queue.append((l, c))

    # Étape 4 : Parcourir la file d'attente et mettre à jour les distances
    while len(queue) > 0:
        # Nous retirons la première cellule de la file d'attente pour l'explorer
        l, c = queue.pop(0)

        # Nous explorons tous les voisins de la cellule actuelle
        for dl, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            # Nous calculons les coordonnées du voisin
            nl, nc = l + dl, c + dc

            # Nous vérifions si le voisin est dans les limites de la grille et n'est pas une route
            if 0 <= nl < LigneU and 0 <= nc < ColonneU and Route[nl][nc] != 1:
                # Nous calculons la distance à travers la cellule actuelle
                new_distance = D[l][c] + 1

                # Si cette nouvelle distance est plus petite que la distance actuelle du voisin, nous mettons à jour la distance du voisin
                if new_distance < D[nl][nc]:
                    D[nl][nc] = new_distance

                    # Nous ajoutons le voisin à la file d'attente pour explorer ses voisins plus tard
                    queue.append((nl, nc))

    # À la fin, D contient la distance minimale de chaque cellule à la cellule habitable la plus proche
    return D


Distance = create_distance_matrix()


def create_border_matrix():
    # Etape 1 : Initialisation de la matrice B
    B = []
    for _ in range(LigneU):
        row = []
        for _ in range(ColonneU):
            row.append(0)
        B.append(row)

    # Etape 2 : Parcourir chaque cellule de la matrice d'utilisation
    for l in range(LigneU):
        for c in range(ColonneU):
            # Etape 3 : Définir les directions pour vérifier les voisins
            directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

            # Etape 4 : Vérifier chaque voisin de la cellule actuelle
            for direction in directions:
                dl, dc = direction
                nl, nc = l + dl, c + dc

                # Etape 5 : Vérifier si le voisin est dans les limites de la matrice
                if 0 <= nl < LigneU and 0 <= nc < ColonneU:
                    # Etape 6 : Vérifier si le voisin est une parcelle non achetée
                    if usage_map[nl][nc] == ' ':
                        # Etape 7 : Si oui, marquer la cellule actuelle comme un bord extérieur
                        B[l][c] = 1
                        # Etape 8 : Pas besoin de vérifier d'autres voisins
                        break

    # Etape 9 : Retourner la matrice B
    return B


Bord = create_border_matrix()

#résolution avec pulp
# Initialisation du problème de programmation linéaire
prob = LpProblem("Optimisation_de_l_achat_de_parcelles", LpMinimize)

# Définition des variables de décision
x = [[LpVariable(f"x_{l}_{c}", cat="Binary") for c in range(ColonneU)] for l in range(LigneU)]

# Définition de la fonction objective
objectif1 = lpSum([production_map[l][c] * x[l][c] for l in range(LigneU) for c in range(ColonneU)])
objectif2 = lpSum([Distance[l][c] * x[l][c] for l in range(LigneU) for c in range(ColonneU)])
objectif3 = lpSum([Bord[l][c] * x[l][c] for l in range(LigneU) for c in range(ColonneU)])

# Nous allons simplement sommer tous les objectifs pour créer une fonction objective agrégée.
prob += objectif1 - objectif2 - objectif3

# Définition des contraintes
for l in range(LigneU):
    for c in range(ColonneU):
        prob += x[l][c] <= 1 - Route[l][c] - Habitation[l][c]  # Ne pas acheter de parcelles occupées par des routes ou des habitations
        prob += cost_map[l][c] * x[l][c] <= 500000  # Respecter le budget

# Résolution du problème
prob.solve()

# Affichage des résultats
for l in range(LigneU):
    for c in range(ColonneU):
        if x[l][c].value() == 1:
            print(f"Parcelle ({l}, {c}) achetée")

# Créer une liste pour stocker les résultats pour chaque jeu de poids
results = []

# Créer une liste de poids à tester
weights = np.linspace(0, 1, 20)

# Itérer sur tous les jeux de poids
for w1 in weights:
    for w2 in weights:
        for w3 in weights:
            # Vérifier que la somme des poids est égale à 1
            if w1 + w2 + w3 != 1:
                continue

            # Créer un nouveau problème
            prob = LpProblem("Optimisation_de_l_achat_de_parcelles", LpMinimize)

            # Définir les variables de décision
            x = [[LpVariable(f"x_{l}_{c}", cat="Binary") for c in range(ColonneU)] for l in range(LigneU)]

            # Définir la fonction objective
            objectif1 = lpSum([production_map[l][c] * x[l][c] for l in range(LigneU) for c in range(ColonneU)])
            objectif2 = lpSum([Distance[l][c] * x[l][c] for l in range(LigneU) for c in range(ColonneU)])
            objectif3 = lpSum([Bord[l][c] * x[l][c] for l in range(LigneU) for c in range(ColonneU)])

            # Nous allons pondérer les objectifs par leurs poids respectifs
            prob += w1 * objectif1 - w2 * objectif2 - w3 * objectif3

            # Définir les contraintes
            for l in range(LigneU):
                for c in range(ColonneU):
                    prob += x[l][c] <= 1 - Route[l][c] - Habitation[l][c]  # Ne pas acheter de parcelles occupées par des routes ou des habitations
                    prob += cost_map[l][c] * x[l][c] <= 500000  # Respecter le budget

            # Résoudre le problème
            prob.solve()

            # Stocker les résultats
            results.append((w1, w2, w3, value(prob.objective)))

# Extraire les valeurs individuelles de la liste des résultats
x_vals = [x[0] for x in results]
y_vals = [x[1] for x in results]
z_vals = [x[2] for x in results]
c_vals = [x[3] for x in results]

# Créer une nouvelle figure
fig = plt.figure()

# Créer un subplot 3D
ax = fig.add_subplot(111, projection='3d')

# Créer le diagramme de dispersion
scatter = ax.scatter(x_vals, y_vals, z_vals, c=c_vals)

# Ajouter des étiquettes aux axes
ax.set_xlabel('Poids pour l\'objectif 1')
ax.set_ylabel('Poids pour l\'objectif 2')
ax.set_zlabel('Poids pour l\'objectif 3')

# Ajouter une barre de couleur
plt.colorbar(scatter)

# Afficher le graphique
plt.show()
