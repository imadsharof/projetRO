import numpy as np
import matplotlib.pyplot as plt
from pulp import LpProblem, LpMaximize, LpVariable, lpSum, value, PULP_CBC_CMD
import tkinter as tk
import csv
import time
Time1= time.time(
)
budget = 50
nb_test = 25
weight= np.linspace(0.2, 1, 10)
combinations = [(w1, w2, 1 - w1 - w2) for w1 in weight for w2 in weight if w1 + w2 <= 1]
pareto_fronts = []
non_sorted = []
best_zone_weight= []
best_zone_score_weight= 0
real_cost_weight = 0
best_total_score_weight = 0

color_mapping = {
    'C': 'blue',
    'R': 'gray',
    'A': 'red',
    '': 'black'
}

#Fonction qui charge les données à partir des fichiers txt
def load_data(file_path):
    try:
        with open(file_path, 'r') as file:
            # Traitement du fichier et retour des données
            data = file.read()
            return data
    except FileNotFoundError:
        print("Erreur : Fichier non trouvé")
    except IOError:
        print("Erreur : Erreur d'entrée/sortie lors de la lecture du fichier")
    except Exception as e:
        print("Erreur : Une erreur inattendue s'est produite")
        print(str(e))


# Fonction qui crée la matrice usage_map
def create_usage_map_matrix(file_path):
    with open(file_path, 'r') as file:
        file_line = file.readlines()
    matrix = []
    for line in file_line:
        matrix_line = []
        for c in line:
            if c == ' ':
                matrix_line.append('')
            elif c == 'R':
                matrix_line.append('R')
            elif c == 'C':
                matrix_line.append('C')
        matrix.append(matrix_line)
    return matrix

### Initalisation de la région : usage_map, cost_map et production_map
"""
usage_map = create_usage_map_matrix("donnes_test/Usage_map_test.txt")
cost_map = load_data("donnes_test/Cost_map_test.txt")
production_map = load_data("donnes_test/Production_map_test.txt")
"""
usage_map = create_usage_map_matrix("donnes_V2/Usage_map.txt")
cost_map = load_data("donnes_V2/Cost_map.txt")
production_map = load_data("donnes_V2/Production_map.txt")


### Indices

columnU = len(usage_map[0])
rowU = len(usage_map)

### Constantes

# Fonction qui crée la matrice route
def create_route_matrix():
    matrix = []
    for l in range(rowU):
        matrix.append([])
        for c in range(columnU) :
            if usage_map[l][c] == "R" :
                matrix[l].append(1)
            else :
                matrix[l].append(0)
    return matrix

Route = create_route_matrix()

# Fonction qui crée la matrice habitation
def create_habitation_matrix():
    matrix = []
    for l in range(rowU) :
        matrix.append([])
        for c in range(columnU) :
            if usage_map[l][c] == "C":
                matrix[l].append(1)
            else :
                matrix[l].append(0)
    return matrix

Habitation = create_habitation_matrix()

# Fonction qui crée la matrice de distance
# Forme de l'algorithme de Dijkstra pour permettre de calculer le plus court chemin entre une parcelle et une habitation H

def create_distance_matrix():
    # Étape 1 : Initialiser la matrice de distance avec de grandes valeurs
    D = []
    for l in range(rowU):
        row = []
        for c in range(columnU):
            # Nous commençons avec une grande valeur pour représenter "l'infini"
            row.append(10000)
        D.append(row)

    # Étape 2 : Mettre la distance à 0 pour toutes les cellules habitables
    for l in range(rowU):
        for c in range(columnU):
            if Habitation[l][c] == 1:
                # Si la cellule est habitable, sa distance à elle-même est 0
                D[l][c] = 0

    # Étape 3 : Initialiser la file d'attente avec les cellules habitables
    queue = []
    for l in range(rowU):
        for c in range(columnU):
            if Habitation[l][c] == 1:
                # Si la cellule est habitable, nous l'ajoutons à la file d'attente pour l'explorer plus tard
                queue.append((l, c))

    # Étape 4 : Parcourir la file d'attente et mettre à jour les distances
    while len(queue) > 0:
        # Nous retirons la première cellule de la file d'attente pour l'explorer
        l, c = queue.pop(0)

        # Nous explorons tous les voisins de la cellule actuelle
        for dl, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            # Nous calculons les coordonnées du voisin
            nl, nc = l + dl, c + dc

            # Nous vérifions si le voisin est dans les limites de la grille et n'est pas une route
            if 0 <= nl < rowU and 0 <= nc < columnU and Route[nl][nc] != 1:
                # Nous calculons la distance à travers la cellule actuelle
                new_distance = D[l][c] + 1

                # Si cette nouvelle distance est plus petite que la distance actuelle du voisin, nous mettons à jour la distance du voisin
                if new_distance < D[nl][nc]:
                    D[nl][nc] = new_distance

                    # Nous ajoutons le voisin à la file d'attente pour explorer ses voisins plus tard
                    queue.append((nl, nc))

    # À la fin, D contient la distance minimale de chaque cellule à la cellule habitable la plus proche
    return D

Distance = create_distance_matrix()

#Fonction qui crée la matrice score
def compactness_score_matrix(rowU, columnU, best_parcel, Habitation, Route):
    score_matrix = np.zeros((rowU, columnU))
    best_l, best_c = best_parcel

    # Calculer les scores de compacité uniquement pour les cellules proches
    for l in range(rowU):
        for c in range(columnU):
            if (l, c) == best_parcel:
                score_matrix[l][c] = 1000  # Score infini pour la meilleure parcelle
            elif Habitation[l][c] == 1 or Route[l][c] == 1:
                score_matrix[l][c] = 0
            else:
                min_distance = abs(l - best_l) + abs(c - best_c)
                if int(50 / (min_distance)**2)> 1:
                    score_matrix[l][c] = int(50 / (min_distance)**2) # Score inverse de la distance minimale
                else:
                    score_matrix[l][c] = -(int((min_distance)**2))
    return score_matrix

#Fonction qui resoud le probleme
def solve_land_purchasing_problem(rowU, columnU, production_map, Distance, score_matrix, Route, Habitation, cost_map, budget, weight_production, weight_distance, weight_compactness):
    # 1. Initialiser le problème et les variables de décision binaires (une pour chaque parcelle).

    model = LpProblem(name="Land_purchasing_problem", sense=LpMaximize)
    parcels = [LpVariable(name=f"Parcel_{l}_{c}", cat="Binary") for l in range(rowU) for c in range(columnU)]

    # 2. Ajouter les contraintes
    # Chaque parcelle ne peut être achetée qu'une fois

    for l in range(rowU):
        for c in range(columnU):
            model += (parcels[l * columnU + c] <= 1 - Route[l][c] - Habitation[l][c], f"Parcel_{l}_{c}_constraint")

    # Respecter le budget
    total_cost = lpSum([cost_map[l][c] * parcels[l * columnU + c] for l in range(rowU) for c in range(columnU)])
    model += (total_cost <= budget, "Budget_constraint")

    # 3. Définir la fonction objectif agrégée
    objective = + weight_production * lpSum([production_map[l][c] * parcels[l * columnU + c] for l in range(rowU) for c in range(columnU)]) \
                - weight_distance * lpSum([Distance[l][c] * parcels[l * columnU + c] for l in range(rowU) for c in range(columnU)]) \
                + weight_compactness * lpSum([score_matrix[l][c] * parcels[l * columnU + c] for l in range(rowU) for c in range(columnU)])

    # Maximiser la fonction objectif agrégée
    model += objective

    # 4. Résoudre le problème

    model.solve(PULP_CBC_CMD(msg=False))
    # Récupérer la valeur de l'objectif "production", "distance" et "compacité"
    valeur_production = value(weight_production*
        lpSum([production_map[l][c] * parcels[l * columnU + c] for l in range(rowU) for c in range(columnU)]))
    valeur_distance = value(weight_distance*
        lpSum([Distance[l][c] * parcels[l * columnU + c] for l in range(rowU) for c in range(columnU)]))
    valeur_compactness = value(weight_compactness*lpSum([score_matrix[l][c] * parcels[l * columnU + c] for l in range(rowU) for c in range(columnU)]))

    valeur = valeur_compactness + valeur_distance + valeur_compactness

    return parcels, valeur, valeur_production, valeur_distance, valeur_compactness

#Fonction qui crée une zone de parcelle
def create_zone(parcels,valeur,weight_production,weight_distance):
    # Récupérer la prochaine parcelle achetée
    price = 0
    zone =[]
    score_zone = 0
    zone_score = []
    for l in range(rowU):
        for c in range(columnU):
            if parcels[l * columnU + c].varValue == 1:
                price += cost_map[l][c]
                score_parcelle=weight_production * production_map[l][c] - (weight_distance) * Distance[l][c]
                score_zone += score_parcelle
                zone.append((l,c))
    zone_score.append([zone,score_zone,price*10000, valeur])
    return zone_score

#Fonction qui cherche établi un classement des meilleurs parcelles
def candidat(ranking_of_candidat, Habitation, Route, weight_production, weight_distance, production_map, Distance):
    candidates =[]
    for l in range(rowU):
        for c in range(columnU):
            if not (Habitation[l][c] == 1) and not (Route[l][c] == 1):
                candidates.append((l, c))
    candidates = sorted(candidates, key=lambda x: -(
            weight_production * production_map[x[0]][x[1]] - (weight_distance) * Distance[x[0]][x[1]]))
    best_parcel = candidates[ranking_of_candidat]
    return best_parcel
def iterate(rowU, columnU, production_map, Distance, Route, Habitation, cost_map, budget, weight_production, weight_distance, weight_compactness):
    test_zone = []
    best_total_score = 0

    for test in range(nb_test):
        best_parcel = candidat(test, Habitation, Route, weight_production, weight_distance, production_map, Distance)

        # Acheter les parcelles autour de la meilleure parcelle en utilisant solve_land_purchasing_problem
        score_matrix = compactness_score_matrix(rowU, columnU, best_parcel, Habitation, Route)
        parcels, valeur, valeur_production, valeur_distance, valeur_compactness = solve_land_purchasing_problem(rowU, columnU, production_map, Distance, score_matrix, Route, Habitation, cost_map, budget, weight_production, weight_distance, weight_compactness)

        zone_score = create_zone(parcels, valeur, weight_production,weight_distance)
        test_zone.append(zone_score)
        if test_zone[test][0][3] > best_total_score :
            best_zone = test_zone[test][0][0]
            best_total_score = test_zone[test][0][3]
            real_best_parcel = best_parcel
            real_cost = test_zone[test][0][2]
    return best_zone,best_total_score, real_best_parcel, real_cost, valeur_production, valeur_distance, valeur_compactness

best_weight_production, best_weight_distance, best_weight_compactness = 0,0,0

for weight_production, weight_distance, weight_compactness in combinations:
    weighted_sums = []
    best_zone, best_total_score, real_best_parcel, real_cost, valeur_production, valeur_distance, valeur_compactness = iterate(rowU,
                                                                                                           columnU,
                                                                                                           production_map,
                                                                                                           Distance,
                                                                                                           Route,
                                                                                                           Habitation,
                                                                                                           cost_map,
                                                                                                           budget, weight_production,
                                                                                                           weight_distance,
                                                                                                            weight_compactness)


    if(best_total_score) >= best_total_score_weight:
        best_zone_weight = best_zone
        best_total_score_weight = best_total_score
        real_cost_weight = real_cost
        best_weight_production, best_weight_distance, best_weight_compactness = weight_production, weight_distance, weight_compactness
    weighted_sum = valeur_production + valeur_distance + valeur_compactness
    weighted_sums.append(weighted_sum)
    non_sorted.append((weighted_sum, valeur_production, valeur_distance, valeur_compactness))
    sorted_solutions = sorted(non_sorted, key=lambda x: x[0])


    pareto_front = []
    max_distance = float('inf')
    max_compacite = float('-inf')

    for weighted_sum, production, distance, compacite in sorted_solutions:
        if distance < max_distance:
            pareto_front.append((production, distance, compacite))
            max_distance = distance
            max_compacite = compacite

    pareto_fronts.append(pareto_front)
fig = plt.figure(figsize=(12, 8))
ax = fig.add_subplot(111, projection='3d')

for i, (weight_production, weight_distance, weight_compactness) in enumerate(combinations):
    pareto_production = [point[0] for point in pareto_fronts[i]]
    pareto_distance = [point[1] for point in pareto_fronts[i]]
    pareto_compacite = [point[2] for point in pareto_fronts[i]]
    plt.plot(pareto_production, pareto_distance, pareto_compacite, marker='o', label=f'Weights ({round(weight_production,1)}, {round(weight_distance,1)}, {round(weight_compactness,1)})')

ax.scatter(sorted_solutions[0][1],sorted_solutions[0][2], sorted_solutions[0][3], color = 'black')

plt.xlabel('Production')
plt.ylabel('Distance')
ax.set_zlabel('Compactness')
plt.title('Pareto Fronts')
plt.legend(loc='upper left', bbox_to_anchor=(0, 1), bbox_transform=plt.gcf().transFigure)
plt.grid(True)
plt.show()

for parcelles in best_zone_weight:
    l,c = parcelles
    usage_map[l][c] = 'A'

print("Parcelle acheté de la zone:", best_zone_weight)
print("Son score est de:", best_total_score_weight)
print("Coût de la zone: ", real_cost_weight, "euros")
print("Poids production:", round(best_weight_production,1) , "Poids distance:", round(best_weight_distance,1) , "Poids compacité:", round(best_weight_compactness,1))
Time2=time.time()

print("Temps d'execution", time.strftime('%H:%M:%S', time.gmtime(Time2-Time1)))


# Définir le chemin du fichier CSV
chemin_fichier = "resultat/resultats.csv"

# Écrire les résultats dans le fichier CSV
with open(chemin_fichier, mode='w', newline='') as fichier_csv:
    writer = csv.writer(fichier_csv)


    # Écrire les résultats
    writer.writerow(["nombre de test", nb_test])
    writer.writerow(["Parcelle achetée de la zone:", best_zone_weight])
    writer.writerow(["Son score est de:", best_total_score_weight])
    writer.writerow(["Coût de la zone:", str(real_cost_weight) + " euros"])
    writer.writerow(["Poids production:", round(weight_production,1), "Poids distance:", round(weight_distance,1), "Poids compacité:", round(weight_compactness,1)])
    writer.writerow(["Temps d'exécution", time.strftime('%H:%M:%S', time.gmtime(Time2-Time1))])



def draw_grid(matrix, rowU, columnU):
    root = tk.Tk()
    root.title("Grid")
    # Taille des carrés de la grille
    square_size = 1200/columnU

    # Création du canevas
    canvas = tk.Canvas(root, width=columnU * square_size, height=rowU * square_size)
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

    # Création de la barre de défilement verticale
    yscrollbar = tk.Scrollbar(root, orient=tk.VERTICAL, command=canvas.yview)
    yscrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Création de la barre de défilement horizontale
    xscrollbar = tk.Scrollbar(root, orient=tk.HORIZONTAL, command=canvas.xview)
    xscrollbar.pack(side=tk.BOTTOM, fill=tk.X)

    # Configuration du canevas pour prendre en compte les défilements
    canvas.configure(yscrollcommand=yscrollbar.set, xscrollcommand=xscrollbar.set)
    canvas.configure(scrollregion=canvas.bbox(tk.ALL))

    # Parcours de la matrice et dessin des éléments
    for row in range(rowU):
        for col in range(columnU):
            element = matrix[row][col]
            color = color_mapping.get(element, 'black')

            # Dessin d'un rectangle avec la couleur correspondante
            canvas.create_rectangle(col * square_size, row * square_size, (col + 1) * square_size, (row + 1) * square_size, fill=color)

    root.mainloop()
draw_grid(usage_map, rowU, columnU)





