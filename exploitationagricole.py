import numpy as np
from mpl_toolkits.mplot3d import Axes3D

import matplotlib.pyplot as plt

from pulp import LpProblem, LpMaximize, LpVariable, lpSum, value, PULP_CBC_CMD
import tkinter as tk
import time

weight_production = 1
weight_distance = 1
weight_compactness = 1
budget= 50
nb_test = 1
color_mapping = {
    'C': 'blue',
    'R': 'gray',
    'A': 'red',
    '': 'black'
}

#Fonction qui charge les données à partir des fichiers txt
def load_data(filename):
    with open(filename, 'r') as f:
        data = [[int(value) for value in line.strip()] for line in f.readlines()]
    return data


# Fonction qui crée la matrice usage_map
def create_usage_map_matrix(file_path):
    with open(file_path, 'r') as file:
        file_line = file.readlines()
    matrix = []
    for line in file_line:
        matrix_line = []
        for c in line:
            if c == ' ':
                matrix_line.append('')
            elif c == 'R':
                matrix_line.append('R')
            elif c == 'C':
                matrix_line.append('C')
        matrix.append(matrix_line)
    return matrix

### Initalisation de la région : usage_map, cost_map et production_map
"""
usage_map = create_usage_map_matrix("donnes_test/Usage_map_test.txt")
cost_map = load_data("donnes_test/Cost_map_test.txt")
production_map = load_data("donnes_test/Production_map_test.txt")
"""
usage_map = create_usage_map_matrix("donnes_V2/Usage_map.txt")
cost_map = load_data("donnes_V2/Cost_map.txt")
production_map = load_data("donnes_V2/Production_map.txt")


### Indices

columnU = len(usage_map[0])
rowU = len(usage_map)

### Constantes

# Fonction qui crée la matrice route
def create_route_matrix():
    matrix = []
    for l in range(rowU):
        matrix.append([])
        for c in range(columnU) :
            if usage_map[l][c] == "R" :
                matrix[l].append(1)
            else :
                matrix[l].append(0)
    return matrix

Route = create_route_matrix()

# Fonction qui crée la matrice habitation
def create_habitation_matrix():
    matrix = []
    for l in range(rowU) :
        matrix.append([])
        for c in range(columnU) :
            if usage_map[l][c] == "C":
                matrix[l].append(1)
            else :
                matrix[l].append(0)
    return matrix

Habitation = create_habitation_matrix()

# Fonction qui crée la matrice de distance
# Forme de l'algorithme de Dijkstra pour permettre de calculer le plus court chemin entre une parcelle et une habitation H

def create_distance_matrix():
    # Étape 1 : Initialiser la matrice de distance avec de grandes valeurs
    D = []
    for l in range(rowU):
        row = []
        for c in range(columnU):
            # Nous commençons avec une grande valeur pour représenter "l'infini"
            row.append(10000)
        D.append(row)

    # Étape 2 : Mettre la distance à 0 pour toutes les cellules habitables
    for l in range(rowU):
        for c in range(columnU):
            if Habitation[l][c] == 1:
                # Si la cellule est habitable, sa distance à elle-même est 0
                D[l][c] = 0

    # Étape 3 : Initialiser la file d'attente avec les cellules habitables
    queue = []
    for l in range(rowU):
        for c in range(columnU):
            if Habitation[l][c] == 1:
                # Si la cellule est habitable, nous l'ajoutons à la file d'attente pour l'explorer plus tard
                queue.append((l, c))

    # Étape 4 : Parcourir la file d'attente et mettre à jour les distances
    while len(queue) > 0:
        # Nous retirons la première cellule de la file d'attente pour l'explorer
        l, c = queue.pop(0)

        # Nous explorons tous les voisins de la cellule actuelle
        for dl, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            # Nous calculons les coordonnées du voisin
            nl, nc = l + dl, c + dc

            # Nous vérifions si le voisin est dans les limites de la grille et n'est pas une route
            if 0 <= nl < rowU and 0 <= nc < columnU and Route[nl][nc] != 1:
                # Nous calculons la distance à travers la cellule actuelle
                new_distance = D[l][c] + 1

                # Si cette nouvelle distance est plus petite que la distance actuelle du voisin, nous mettons à jour la distance du voisin
                if new_distance < D[nl][nc]:
                    D[nl][nc] = new_distance

                    # Nous ajoutons le voisin à la file d'attente pour explorer ses voisins plus tard
                    queue.append((nl, nc))

    # À la fin, D contient la distance minimale de chaque cellule à la cellule habitable la plus proche
    return D

Distance = create_distance_matrix()

def calculate_compactness(parcel_list):
    adjacent_count = 0
    total_count = len(parcel_list)

    for tpl in parcel_list:
        row, col = tpl
        adjacent_tuples = [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)]
        for adjacent_tpl in adjacent_tuples:
            if adjacent_tpl in parcel_list:
                adjacent_count += 1

    if total_count > 0:
        compactness = adjacent_count / total_count
    else:
        compactness = 0
    return compactness


def compactness_score_matrix(rowU, columnU, best_parcel, Habitation, Route):
    score_matrix = np.zeros((rowU, columnU))
    best_l, best_c = best_parcel

    # Calculer les scores de compacité uniquement pour les cellules proches
    for l in range(rowU):
        for c in range(columnU):
            if (l, c) == best_parcel:
                score_matrix[l][c] = 1000  # Score infini pour la meilleure parcelle
            elif Habitation[l][c] == 1 or Route[l][c] == 1:
                score_matrix[l][c] = 0
            else:
                min_distance = abs(l - best_l) + abs(c - best_c)
                score_matrix[l][c] = int(100 / (min_distance**2))  # Score inverse de la distance minimale

    return score_matrix

def solve_land_purchasing_problem(rowU, columnU, production_map, Distance, score_matrix, Route, Habitation, cost_map, budget, weight_production, weight_distance, weight_compactness):
    # 1. Initialiser le problème et les variables de décision binaires (une pour chaque parcelle).

    model = LpProblem(name="Land_purchasing_problem", sense=LpMaximize)
    parcels = [LpVariable(name=f"Parcel_{l}_{c}", cat="Binary") for l in range(rowU) for c in range(columnU)]

    # 2. Ajouter les contraintes
    # Chaque parcelle ne peut être achetée qu'une fois

    for l in range(rowU):
        for c in range(columnU):
            model += (parcels[l * columnU + c] <= 1 - Route[l][c] - Habitation[l][c], f"Parcel_{l}_{c}_constraint")

    # Respecter le budget
    total_cost = lpSum([cost_map[l][c] * parcels[l * columnU + c] for l in range(rowU) for c in range(columnU)])
    model += (total_cost <= budget, "Budget_constraint")

    # 3. Définir la fonction objectif agrégée
    objective = + weight_production * lpSum([production_map[l][c] * parcels[l * columnU + c] for l in range(rowU) for c in range(columnU)]) \
                - weight_distance * lpSum([Distance[l][c] * parcels[l * columnU + c] for l in range(rowU) for c in range(columnU)]) \
                + weight_compactness * lpSum([score_matrix[l][c] * parcels[l * columnU + c] for l in range(rowU) for c in range(columnU)])
    # Maximiser la fonction objectif agrégée
    model += objective

    # 4. Résoudre le problème

    model.solve(PULP_CBC_CMD(msg=False))
    valeur = value(model.objective)

    return parcels, valeur

def create_zone(parcels,valeur):
    # Récupérer la prochaine parcelle achetée
    price = 0
    zone =[]
    score_zone = 0
    zone_score = []
    for l in range(rowU):
        for c in range(columnU):
            if parcels[l * columnU + c].varValue == 1:
                price += cost_map[l][c]
                score_parcelle=weight_production * production_map[l][c] - (weight_distance) * Distance[l][c]
                score_zone += score_parcelle
                zone.append((l,c))
    zone_score.append([zone,score_zone,price*10000, valeur])
    return zone_score

def candidat(ranking_of_candidat, Habitation, Route, weight_production, weight_distance, production_map, Distance):
    candidates =[]
    for l in range(rowU):
        for c in range(columnU):
            if not (Habitation[l][c] == 1) and not (Route[l][c] == 1):
                candidates.append((l, c))
    candidates = sorted(candidates, key=lambda x: -(
            weight_production * production_map[x[0]][x[1]] - (weight_distance) * Distance[x[0]][x[1]]))
    best_parcel = candidates[ranking_of_candidat]
    return best_parcel
def iterate(rowU, columnU, production_map, Distance, Route, Habitation, cost_map, budget, weight_production, weight_distance, weight_compactness):
    test_zone = []
    best_total_score = 0
    for test in range(nb_test):
        best_parcel = candidat(test, Habitation, Route, weight_production, weight_distance, production_map, Distance)
        # Acheter les parcelles autour de la meilleure parcelle en utilisant solve_land_purchasing_problem
        score_matrix = compactness_score_matrix(rowU, columnU, best_parcel, Habitation, Route)
        parcels, valeur = solve_land_purchasing_problem(rowU, columnU, production_map, Distance, score_matrix, Route, Habitation, cost_map, budget, weight_production, weight_distance, weight_compactness)

        zone_score = create_zone(parcels, valeur)
        test_zone.append(zone_score)
        """
        print(f"Test numéro {test + 1}:")
        print("Test sur la zone", test, "autour de la parcelle", ":", best_parcel)
        print("Parcelle acheté de la zone:", test_zone[test][0][0])
        print("Score de la zone: ", test_zone[test][0][1])
        print("Coût de la zone: ", test_zone[test][0][2], "euros")
        """

        if test_zone[test][0][3] > best_total_score :
            best_zone = test_zone[test][0][0]
            best_total_score = test_zone[test][0][3]
            real_best_parcel = best_parcel
            real_cost = test_zone[test][0][2]
    return best_zone,best_total_score, real_best_parcel, real_cost

best_zone,best_total_score, real_best_parcel, real_cost = iterate(rowU, columnU, production_map, Distance,  Route, Habitation, cost_map, budget, weight_production, weight_distance, weight_compactness)
print("La meilleur zone sera autour de la parcelle:", real_best_parcel)
print("Parcelle acheté de la zone:", best_zone)
print("Son score est de:", best_total_score)
print("Sa compacité est de :",weight_compactness * calculate_compactness(best_zone))
print("Coût de la zone: ", real_cost, "euros")
for parcelles in best_zone:
    l,c = parcelles
    usage_map[l][c] = 'A'



def draw_grid(matrix, rowU, columnU):
    root = tk.Tk()
    root.title("Grid")
    # Taille des carrés de la grille
    square_size = 1200/columnU

    # Création du canevas
    canvas = tk.Canvas(root, width=columnU * square_size, height=rowU * square_size)
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

    # Création de la barre de défilement verticale
    yscrollbar = tk.Scrollbar(root, orient=tk.VERTICAL, command=canvas.yview)
    yscrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Création de la barre de défilement horizontale
    xscrollbar = tk.Scrollbar(root, orient=tk.HORIZONTAL, command=canvas.xview)
    xscrollbar.pack(side=tk.BOTTOM, fill=tk.X)

    # Configuration du canevas pour prendre en compte les défilements
    canvas.configure(yscrollcommand=yscrollbar.set, xscrollcommand=xscrollbar.set)
    canvas.configure(scrollregion=canvas.bbox(tk.ALL))

    # Parcours de la matrice et dessin des éléments
    for row in range(rowU):
        for col in range(columnU):
            element = matrix[row][col]
            color = color_mapping.get(element, 'black')

            # Dessin d'un rectangle avec la couleur correspondante
            canvas.create_rectangle(col * square_size, row * square_size, (col + 1) * square_size, (row + 1) * square_size, fill=color)

    root.mainloop()
draw_grid(usage_map, rowU, columnU)





